#!/bin/bash
#
# postman-report - Fetch Postman team reports via CLI
#

set -euo pipefail

POSTMANRC="$HOME/.postman/postmanrc"
API_BASE="https://go.postman.co/_api/ws/proxy"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $*" >&2; }
log_success() { echo -e "${GREEN}[OK]${NC} $*" >&2; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*" >&2; }
log_error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }

# ============================================================================
# Authentication
# ============================================================================

check_postman_cli() {
  if ! command -v postman &> /dev/null; then
    log_error "Postman CLI not found. Install via: npm install -g postman-cli"
    exit 1
  fi
}

check_logged_in() {
  [[ -f "$POSTMANRC" ]] && [[ -n "$(jq -r '.login._profiles[0].accessToken // empty' "$POSTMANRC" 2>/dev/null)" ]]
}

get_access_token() {
  jq -r '.login._profiles[0].accessToken // empty' "$POSTMANRC" 2>/dev/null
}

do_login() {
  log_info "Starting Postman login..."
  postman login
  check_logged_in || { log_error "Login failed."; exit 1; }
  log_success "Logged in as: $(jq -r '.login._profiles[0].username' "$POSTMANRC")"
}

# ============================================================================
# API Fetchers
# ============================================================================

# Fetch v2 stored reports (simple reportOptions structure)
fetch_stored_report() {
  local report_name="$1"
  local report_options="${2:-{}}"

  local payload=$(jq -nc \
    --arg p "/v2/reports/stored/${report_name}?version=v0" \
    --argjson opts "$report_options" \
    '{service:"report",method:"post",path:$p,body:{reportOptions:$opts}}')

  local response=$(curl -s -w "\n%{http_code}" "$API_BASE" \
    -H 'content-type: application/json' \
    -H "x-access-token: $(get_access_token)" \
    -d "$payload")

  local http_code=$(echo "$response" | tail -n1)
  local body=$(echo "$response" | sed '$d')

  if [[ "$http_code" -eq 200 ]]; then
    echo "$body"
  elif [[ "$http_code" -eq 403 ]]; then
    log_error "Auth failed or feature not available. Run: postman-report --login"
    exit 1
  else
    log_error "Request failed (HTTP $http_code)"
    echo "$body" >&2
    exit 1
  fi
}

# Fetch v2 report groups (returns multiple reports)
fetch_group_report() {
  local group_name="$1"
  local report_options="${2:-{}}"

  local payload=$(jq -nc \
    --arg p "/v2/reports/group/${group_name}?version=v0" \
    --argjson opts "$report_options" \
    '{service:"report",method:"post",path:$p,body:{reportOptions:$opts}}')

  local response=$(curl -s -w "\n%{http_code}" "$API_BASE" \
    -H 'content-type: application/json' \
    -H "x-access-token: $(get_access_token)" \
    -d "$payload")

  local http_code=$(echo "$response" | tail -n1)
  local body=$(echo "$response" | sed '$d')

  if [[ "$http_code" -eq 200 ]]; then
    echo "$body"
  elif [[ "$http_code" -eq 403 ]]; then
    log_error "Auth failed or feature not available."
    exit 1
  else
    log_error "Request failed (HTTP $http_code)"
    echo "$body" >&2
    exit 1
  fi
}

# Fetch simple GET endpoints (v1 APIs)
fetch_get_endpoint() {
  local path="$1"

  local payload=$(jq -nc --arg p "$path" '{service:"report",method:"get",path:$p}')

  local response=$(curl -s -w "\n%{http_code}" "$API_BASE" \
    -H 'content-type: application/json' \
    -H "x-access-token: $(get_access_token)" \
    -d "$payload")

  local http_code=$(echo "$response" | tail -n1)
  local body=$(echo "$response" | sed '$d')

  if [[ "$http_code" -eq 200 ]]; then
    echo "$body"
  elif [[ "$http_code" -eq 403 ]]; then
    log_error "Auth failed or feature not available."
    exit 1
  else
    log_error "Request failed (HTTP $http_code)"
    echo "$body" >&2
    exit 1
  fi
}

# Fetch v3 views (flexible dimensions/measures structure)
fetch_view_report() {
  local view_path="$1"
  local dimensions="$2"
  local measures="$3"
  local filters="${4:-[]}"
  local order_by="${5:-}"

  local body
  if [[ -n "$order_by" ]]; then
    body=$(jq -nc \
      --argjson dims "$dimensions" \
      --argjson meas "$measures" \
      --argjson filt "$filters" \
      --argjson ord "$order_by" \
      '{dimensions:$dims,measures:$meas,filters:$filt,orderBy:$ord}')
  else
    body=$(jq -nc \
      --argjson dims "$dimensions" \
      --argjson meas "$measures" \
      --argjson filt "$filters" \
      '{dimensions:$dims,measures:$meas,filters:$filt}')
  fi

  local payload=$(jq -nc \
    --arg p "$view_path" \
    --argjson b "$body" \
    '{service:"report",method:"post",path:$p,body:$b}')

  local response=$(curl -s -w "\n%{http_code}" "$API_BASE" \
    -H 'content-type: application/json' \
    -H "x-access-token: $(get_access_token)" \
    -d "$payload")

  local http_code=$(echo "$response" | tail -n1)
  local body=$(echo "$response" | sed '$d')

  if [[ "$http_code" -eq 200 ]]; then
    echo "$body"
  elif [[ "$http_code" -eq 403 ]]; then
    log_error "Auth failed or feature not available."
    exit 1
  else
    log_error "Request failed (HTTP $http_code)"
    echo "$body" >&2
    exit 1
  fi
}

# ============================================================================
# User Reports (v3 BillingUsersDimension)
# ============================================================================

get_user_report_config() {
  case "$1" in
    users)    echo '{"dimensions":["userName","email","userAddedInTeam","lastActiveDate","userRole","invitedBy","inviteType","publicProfileEnabled"],"measures":[],"filters":[]}' ;;
    activity) echo '{"dimensions":["userName","email","lastActiveDate"],"measures":["totalApiRequests","totalCollectionRuns"],"filters":[]}' ;;
    roles)    echo '{"dimensions":["userName","email","userRole"],"measures":[],"filters":[]}' ;;
    *)        echo "" ;;
  esac
}

fetch_user_report() {
  local report_type="$1"
  local body=$(get_user_report_config "$report_type")

  [[ -z "$body" ]] && return 1

  local payload=$(jq -nc --arg p "/v3/views/BillingUsersDimension" --argjson b "$body" '{service:"report",method:"post",path:$p,body:$b}')

  local response=$(curl -s -w "\n%{http_code}" "$API_BASE" \
    -H 'content-type: application/json' \
    -H "x-access-token: $(get_access_token)" \
    -d "$payload")

  local http_code=$(echo "$response" | tail -n1)
  local body=$(echo "$response" | sed '$d')

  if [[ "$http_code" -eq 200 ]]; then
    echo "$body"
  elif [[ "$http_code" -eq 403 ]]; then
    log_error "Auth failed. Run: postman-report --login"
    exit 1
  else
    log_error "Request failed (HTTP $http_code)"
    echo "$body" >&2
    exit 1
  fi
}

# ============================================================================
# Formatters - User Reports
# ============================================================================

format_users_table() {
  local json="$1" type="$2"
  case "$type" in
    users)
      echo "$json" | jq -r '["NAME","EMAIL","JOINED","LAST_ACTIVE","ROLES"],(.data[]|[.dimensions.userName,.dimensions.email,.dimensions.userAddedInTeam,.dimensions.lastActiveDate,.dimensions.userRole])|@tsv' | column -t -s $'\t' ;;
    activity)
      echo "$json" | jq -r '["NAME","EMAIL","LAST_ACTIVE","API_REQUESTS","RUNS"],(.data[]|[.dimensions.userName,.dimensions.email,.dimensions.lastActiveDate,(.measures.totalApiRequests//"N/A"),(.measures.totalCollectionRuns//"N/A")])|@tsv' | column -t -s $'\t' ;;
    roles)
      echo "$json" | jq -r '["NAME","EMAIL","ROLES"],(.data[]|[.dimensions.userName,.dimensions.email,.dimensions.userRole])|@tsv' | column -t -s $'\t' ;;
  esac
}

format_users_csv() {
  local json="$1" type="$2"
  case "$type" in
    users)
      echo "$json" | jq -r '["userName","email","userAddedInTeam","lastActiveDate","userRole","invitedBy","inviteType","publicProfileEnabled"],(.data[]|[.dimensions.userName,.dimensions.email,.dimensions.userAddedInTeam,.dimensions.lastActiveDate,.dimensions.userRole,.dimensions.invitedBy,.dimensions.inviteType,.dimensions.publicProfileEnabled])|@csv' ;;
    activity)
      echo "$json" | jq -r '["userName","email","lastActiveDate","totalApiRequests","totalCollectionRuns"],(.data[]|[.dimensions.userName,.dimensions.email,.dimensions.lastActiveDate,(.measures.totalApiRequests//""),(.measures.totalCollectionRuns//"")])|@csv' ;;
    roles)
      echo "$json" | jq -r '["userName","email","userRole"],(.data[]|[.dimensions.userName,.dimensions.email,.dimensions.userRole])|@csv' ;;
  esac
}

# ============================================================================
# Formatters - Bar Chart Data (distribution reports)
# ============================================================================

format_bar_table() {
  local json="$1" label_col="$2"
  echo "$json" | jq -r --arg lbl "$label_col" '
    [($lbl|ascii_upcase), "COUNT"],
    (.data.dataset[]|[.legend, (.values[0].y // 0)])|@tsv' | column -t -s $'\t'
}

format_bar_csv() {
  local json="$1" label_col="$2"
  echo "$json" | jq -r --arg lbl "$label_col" '
    [$lbl, "count"],
    (.data.dataset[]|[.legend, (.values[0].y // 0)])|@csv'
}

# ============================================================================
# Formatters - Time Series Data
# ============================================================================

format_timeseries_table() {
  local json="$1" limit="${2:-10}"
  echo "$json" | jq -r --argjson lim "$limit" '
    ["DATE", "VALUE"],
    (.data.dataset[0].values | if length > $lim then .[-$lim:] else . end | .[] | [.x, .y])|@tsv' | column -t -s $'\t'
}

format_timeseries_csv() {
  local json="$1"
  echo "$json" | jq -r '
    ["date", "value"],
    (.data.dataset[0].values[]|[.x, .y])|@csv'
}

# ============================================================================
# Formatters - Coverage Reports
# ============================================================================

format_coverage_table() {
  local mocks="$1" monitors="$2" tests="$3" docs="$4"

  local m_with=$(echo "$mocks" | jq -r '.data.dataset[0].values[0].x // 0')
  local m_without=$(echo "$mocks" | jq -r '.data.dataset[1].values[0].x // 0')
  local mon_with=$(echo "$monitors" | jq -r '.data.dataset[0].values[0].x // 0')
  local mon_without=$(echo "$monitors" | jq -r '.data.dataset[1].values[0].x // 0')
  local t_with=$(echo "$tests" | jq -r '.data.dataset[0].values[0].x // 0')
  local t_without=$(echo "$tests" | jq -r '.data.dataset[1].values[0].x // 0')
  local d_with=$(echo "$docs" | jq -r '.data.dataset[0].values[0].x // 0')
  local d_without=$(echo "$docs" | jq -r '.data.dataset[1].values[0].x // 0')

  printf "%-15s %10s %10s %10s\n" "TYPE" "WITH" "WITHOUT" "COVERAGE"
  printf "%-15s %10d %10d %9.1f%%\n" "Mocks" "$m_with" "$m_without" "$(echo "scale=1; $m_with * 100 / ($m_with + $m_without + 0.001)" | bc)"
  printf "%-15s %10d %10d %9.1f%%\n" "Monitors" "$mon_with" "$mon_without" "$(echo "scale=1; $mon_with * 100 / ($mon_with + $mon_without + 0.001)" | bc)"
  printf "%-15s %10d %10d %9.1f%%\n" "Tests" "$t_with" "$t_without" "$(echo "scale=1; $t_with * 100 / ($t_with + $t_without + 0.001)" | bc)"
  printf "%-15s %10d %10d %9.1f%%\n" "Documentation" "$d_with" "$d_without" "$(echo "scale=1; $d_with * 100 / ($d_with + $d_without + 0.001)" | bc)"
}

format_coverage_csv() {
  local mocks="$1" monitors="$2" tests="$3" docs="$4"

  echo "type,with,without,coverage_pct"

  local m_with=$(echo "$mocks" | jq -r '.data.dataset[0].values[0].x // 0')
  local m_without=$(echo "$mocks" | jq -r '.data.dataset[1].values[0].x // 0')
  local mon_with=$(echo "$monitors" | jq -r '.data.dataset[0].values[0].x // 0')
  local mon_without=$(echo "$monitors" | jq -r '.data.dataset[1].values[0].x // 0')
  local t_with=$(echo "$tests" | jq -r '.data.dataset[0].values[0].x // 0')
  local t_without=$(echo "$tests" | jq -r '.data.dataset[1].values[0].x // 0')
  local d_with=$(echo "$docs" | jq -r '.data.dataset[0].values[0].x // 0')
  local d_without=$(echo "$docs" | jq -r '.data.dataset[1].values[0].x // 0')

  printf "Mocks,%d,%d,%.1f\n" "$m_with" "$m_without" "$(echo "scale=1; $m_with * 100 / ($m_with + $m_without + 0.001)" | bc)"
  printf "Monitors,%d,%d,%.1f\n" "$mon_with" "$mon_without" "$(echo "scale=1; $mon_with * 100 / ($mon_with + $mon_without + 0.001)" | bc)"
  printf "Tests,%d,%d,%.1f\n" "$t_with" "$t_without" "$(echo "scale=1; $t_with * 100 / ($t_with + $t_without + 0.001)" | bc)"
  printf "Documentation,%d,%d,%.1f\n" "$d_with" "$d_without" "$(echo "scale=1; $d_with * 100 / ($d_with + $d_without + 0.001)" | bc)"
}

# ============================================================================
# Formatters - Entity Counts
# ============================================================================

format_entities_table() {
  local json="$1"
  echo "$json" | jq -r '
    ["ENTITY", "COUNT"],
    (.data.dataset[]|[.legend, (.values[0].y // 0)])|@tsv' | column -t -s $'\t'
}

format_entities_csv() {
  local json="$1"
  echo "$json" | jq -r '
    ["entity", "count"],
    (.data.dataset[]|[.legend, (.values[0].y // 0)])|@csv'
}

# ============================================================================
# Report Implementations
# ============================================================================

report_summary() {
  local format="$1"
  log_info "Fetching summary data..."

  local total_apis=$(fetch_stored_report "totalAPIs")
  local team_apis=$(fetch_stored_report "teamTotalApisInTeamWorkspace")
  local total_ws=$(fetch_stored_report "totalWorkspaces")
  local entities=$(fetch_stored_report "teamWorkspaceEntities")

  log_success "Done."

  if [[ "$format" == "json" ]]; then
    jq -nc \
      --argjson apis "$total_apis" \
      --argjson team "$team_apis" \
      --argjson ws "$total_ws" \
      --argjson ent "$entities" \
      '{totalAPIs:$apis.data,teamAPIs:$team.data,totalWorkspaces:$ws.data,entities:$ent.data}'
  elif [[ "$format" == "csv" ]]; then
    echo "metric,value"
    echo "Total APIs,$(echo "$total_apis" | jq -r '.data')"
    echo "APIs in Team Workspaces,$(echo "$team_apis" | jq -r '.data')"
    echo "Total Workspaces,$(echo "$total_ws" | jq -r '.data')"
    echo "$entities" | jq -r '.data.dataset[]|[.legend, (.values[0].y // 0)]|@csv'
  else
    printf "%-30s %10s\n" "METRIC" "VALUE"
    printf "%-30s %10d\n" "Total APIs" "$(echo "$total_apis" | jq -r '.data')"
    printf "%-30s %10d\n" "APIs in Team Workspaces" "$(echo "$team_apis" | jq -r '.data')"
    printf "%-30s %10d\n" "Total Workspaces" "$(echo "$total_ws" | jq -r '.data')"
    echo "$entities" | jq -r '.data.dataset[]|[.legend, (.values[0].y // 0)]|@tsv' | while IFS=$'\t' read -r name count; do
      printf "%-30s %10d\n" "$name" "$count"
    done
  fi
}

report_apis() {
  local format="$1"
  log_info "Fetching API distribution..."
  local json=$(fetch_stored_report "distributionOfApis")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)   format_bar_csv "$json" "workspace_type" ;;
    table) format_bar_table "$json" "WORKSPACE_TYPE" ;;
  esac
}

report_workspaces() {
  local format="$1"
  log_info "Fetching workspace distribution..."
  local json=$(fetch_stored_report "workspacesByType")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)   format_bar_csv "$json" "visibility" ;;
    table) format_bar_table "$json" "VISIBILITY" ;;
  esac
}

report_schemas() {
  local format="$1"
  log_info "Fetching schema distribution..."
  local json=$(fetch_stored_report "teamSchemasType")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)   format_bar_csv "$json" "schema_type" ;;
    table) format_bar_table "$json" "SCHEMA_TYPE" ;;
  esac
}

report_entities() {
  local format="$1"
  log_info "Fetching entity counts..."
  local json=$(fetch_stored_report "teamWorkspaceEntities")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)   format_entities_csv "$json" ;;
    table) format_entities_table "$json" ;;
  esac
}

report_coverage() {
  local format="$1" subtype="${2:-all}"

  if [[ "$subtype" != "all" ]]; then
    local endpoint
    case "$subtype" in
      mocks)    endpoint="teamApiWithMocks" ;;
      monitors) endpoint="teamApiWithMonitors" ;;
      tests)    endpoint="teamApiWithTest" ;;
      docs)     endpoint="teamApiWithDocumentation" ;;
      *) log_error "Unknown coverage type: $subtype"; exit 1 ;;
    esac

    log_info "Fetching $subtype coverage..."
    local json=$(fetch_stored_report "$endpoint")
    log_success "Done."

    case "$format" in
      json)  echo "$json" ;;
      csv)
        local w=$(echo "$json" | jq -r '.data.dataset[0].values[0].x // 0')
        local wo=$(echo "$json" | jq -r '.data.dataset[1].values[0].x // 0')
        echo "status,count"
        echo "with_${subtype},$w"
        echo "without_${subtype},$wo"
        ;;
      table)
        local w=$(echo "$json" | jq -r '.data.dataset[0].values[0].x // 0')
        local wo=$(echo "$json" | jq -r '.data.dataset[1].values[0].x // 0')
        printf "%-20s %10s\n" "STATUS" "COUNT"
        printf "%-20s %10d\n" "With ${subtype}" "$w"
        printf "%-20s %10d\n" "Without ${subtype}" "$wo"
        ;;
    esac
    return
  fi

  log_info "Fetching coverage data..."
  local mocks=$(fetch_stored_report "teamApiWithMocks")
  local monitors=$(fetch_stored_report "teamApiWithMonitors")
  local tests=$(fetch_stored_report "teamApiWithTest")
  local docs=$(fetch_stored_report "teamApiWithDocumentation")
  log_success "Done."

  case "$format" in
    json)
      jq -nc \
        --argjson m "$mocks" \
        --argjson mon "$monitors" \
        --argjson t "$tests" \
        --argjson d "$docs" \
        '{mocks:$m,monitors:$mon,tests:$t,documentation:$d}'
      ;;
    csv)   format_coverage_csv "$mocks" "$monitors" "$tests" "$docs" ;;
    table) format_coverage_table "$mocks" "$monitors" "$tests" "$docs" ;;
  esac
}

report_trends() {
  local format="$1" limit="${2:-10}"
  log_info "Fetching trend data..."

  local apis_created=$(fetch_stored_report "apisCreatedOverTime")
  local ws_created=$(fetch_stored_report "workspacesCreatedOverTime")
  local active_ws=$(fetch_stored_report "activeWorkspacesOverTime")

  log_success "Done."

  case "$format" in
    json)
      jq -nc \
        --argjson a "$apis_created" \
        --argjson w "$ws_created" \
        --argjson aw "$active_ws" \
        '{apisCreated:$a,workspacesCreated:$w,activeWorkspaces:$aw}'
      ;;
    csv)
      echo "# APIs Created Over Time"
      format_timeseries_csv "$apis_created"
      echo ""
      echo "# Workspaces Created Over Time"
      format_timeseries_csv "$ws_created"
      ;;
    table)
      echo "=== APIs Created Over Time ==="
      format_timeseries_table "$apis_created" "$limit"
      echo ""
      echo "=== Workspaces Created Over Time ==="
      format_timeseries_table "$ws_created" "$limit"
      ;;
  esac
}

report_api_health() {
  local format="$1" limit="${2:-10}"
  log_info "Fetching API health data..."

  local test_results=$(fetch_stored_report "teamTestResult")
  local uptime=$(fetch_stored_report "teamApiUptime")
  local response_time=$(fetch_stored_report "teamResponseTime")

  log_success "Done."

  case "$format" in
    json)
      jq -nc \
        --argjson t "$test_results" \
        --argjson u "$uptime" \
        --argjson r "$response_time" \
        '{testResults:$t,uptime:$u,responseTime:$r}'
      ;;
    csv)
      echo "# Test Results"
      echo "$test_results" | jq -r '["date","passed","failed"],(.data.dataset as $d | ($d[0].values | keys[]) as $i | [$d[0].values[$i].x, $d[0].values[$i].y, ($d[1].values[$i].y // 0)])|@csv'
      ;;
    table)
      echo "=== Test Results (Recent) ==="
      echo "$test_results" | jq -r --argjson lim "$limit" '
        ["DATE", "PASSED", "FAILED"],
        (.data.dataset as $d | ($d[0].values | if length > $lim then .[-$lim:] else . end | keys[]) as $i |
          [($d[0].values | if length > $lim then .[-$lim:] else . end)[$i].x,
           ($d[0].values | if length > $lim then .[-$lim:] else . end)[$i].y,
           (($d[1].values | if length > $lim then .[-$lim:] else . end)[$i].y // 0)])|@tsv' | column -t -s $'\t'
      ;;
  esac
}

report_engagement() {
  local format="$1" limit="${2:-10}"
  log_info "Fetching engagement data..."

  local watches=$(fetch_stored_report "teamWatchesOvertime")
  local comments=$(fetch_stored_report "teamCommentsOvertime")

  log_success "Done."

  case "$format" in
    json)
      jq -nc \
        --argjson w "$watches" \
        --argjson c "$comments" \
        '{watches:$w,comments:$c}'
      ;;
    csv)
      echo "# Watches Over Time"
      format_timeseries_csv "$watches"
      echo ""
      echo "# Comments Over Time"
      format_timeseries_csv "$comments"
      ;;
    table)
      echo "=== Watches Over Time ==="
      format_timeseries_table "$watches" "$limit"
      echo ""
      echo "=== Comments Over Time ==="
      format_timeseries_table "$comments" "$limit"
      ;;
  esac
}

report_collections() {
  local format="$1"
  log_info "Fetching collections list..."
  local json=$(fetch_stored_report "teamWorkspaceCollectionDrill")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "collection_name,collection_path"
      echo "$json" | jq -r '.data.dataset[]|[.value.collectionName, .details[0].redirectPath]|@csv'
      ;;
    table)
      echo "$json" | jq -r '
        ["COLLECTION_NAME", "PATH"],
        (.data.dataset[]|[.value.collectionName, .details[0].redirectPath])|@tsv' | column -t -s $'\t'
      ;;
  esac
}

report_apis_list() {
  local format="$1"
  log_info "Fetching APIs list..."
  local json=$(fetch_stored_report "teamWorkspaceApiDrill")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "api_name,api_path,report_path"
      echo "$json" | jq -r '.data.dataset[]|[.value.apiName, .details[0].redirectPath, .details[1].redirectPath]|@csv'
      ;;
    table)
      echo "$json" | jq -r '
        ["API_NAME", "PATH"],
        (.data.dataset[]|[.value.apiName, .details[0].redirectPath])|@tsv' | column -t -s $'\t'
      ;;
  esac
}

report_environments() {
  local format="$1"
  log_info "Fetching environments list..."
  local json=$(fetch_stored_report "teamWorkspaceEnvironmentDrill")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "environment_name,environment_path"
      echo "$json" | jq -r '.data.dataset[]|[.value.environmentName, .details[0].redirectPath]|@csv'
      ;;
    table)
      echo "$json" | jq -r '
        ["ENVIRONMENT_NAME", "PATH"],
        (.data.dataset[]|[.value.environmentName, .details[0].redirectPath])|@tsv' | column -t -s $'\t'
      ;;
  esac
}

report_mocks() {
  local format="$1"
  log_info "Fetching mocks list..."
  local json=$(fetch_stored_report "teamWorkspaceMockDrill")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "mock_name,mock_path"
      echo "$json" | jq -r '.data.dataset[]|[.value.mockName, .details[0].redirectPath]|@csv'
      ;;
    table)
      echo "$json" | jq -r '
        ["MOCK_NAME", "PATH"],
        (.data.dataset[]|[.value.mockName, .details[0].redirectPath])|@tsv' | column -t -s $'\t'
      ;;
  esac
}

report_monitors() {
  local format="$1"
  log_info "Fetching monitors list..."
  local json=$(fetch_stored_report "teamWorkspaceMonitorDrill")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "monitor_name,monitor_path"
      echo "$json" | jq -r '.data.dataset[]|[.value.monitorName, .details[0].redirectPath]|@csv'
      ;;
    table)
      echo "$json" | jq -r '
        ["MONITOR_NAME", "PATH"],
        (.data.dataset[]|[.value.monitorName, .details[0].redirectPath])|@tsv' | column -t -s $'\t'
      ;;
  esac
}

report_forks() {
  local format="$1" limit="${2:-10}"
  log_info "Fetching forks & PRs data..."
  local json=$(fetch_stored_report "teamWSForksPullRequestsOverTime")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "date,forks,pull_requests"
      echo "$json" | jq -r '
        .data.dataset as $d |
        ($d[0].values | keys[]) as $i |
        [$d[0].values[$i].x, $d[0].values[$i].y, ($d[1].values[$i].y // 0)]|@csv'
      ;;
    table)
      echo "$json" | jq -r --argjson lim "$limit" '
        ["DATE", "FORKS", "PULL_REQUESTS"],
        (.data.dataset as $d |
          ($d[0].values | if length > $lim then .[-$lim:] else . end | keys[]) as $i |
          [($d[0].values | if length > $lim then .[-$lim:] else . end)[$i].x,
           ($d[0].values | if length > $lim then .[-$lim:] else . end)[$i].y,
           (($d[1].values | if length > $lim then .[-$lim:] else . end)[$i].y // 0)])|@tsv' | column -t -s $'\t'
      ;;
  esac
}

report_pan() {
  local format="$1"
  log_info "Fetching Private API Network report..."
  local json=$(fetch_group_report "privateNetworkApis")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "metric,value"
      echo "$json" | jq -r '.summary | to_entries[] | [.key, .value] | @csv'
      ;;
    table)
      printf "%-30s %10s\n" "METRIC" "VALUE"
      echo "$json" | jq -r '.summary | to_entries[] | [.key, .value] | @tsv' | while IFS=$'\t' read -r key val; do
        printf "%-30s %10s\n" "$key" "$val"
      done
      ;;
  esac
}

report_team() {
  local format="$1"
  log_info "Fetching team info..."

  local name=$(fetch_view_report "/v3/views/TeamBillingDimension" '["teamName"]' '[]')
  local created=$(fetch_view_report "/v3/views/TeamBillingDimension" '["teamCreatedDate"]' '[]')
  local plan=$(fetch_view_report "/v3/views/TeamBillingDimension" '["currentPlan"]' '[]')
  local billing=$(fetch_view_report "/v3/views/TeamBillingDimension" '["billingFrequency"]' '[]')
  local renewal=$(fetch_view_report "/v3/views/TeamBillingDimension" '["nextRenewalDate"]' '[]')
  local members=$(fetch_view_report "/v3/views/TeamBillingDimension" '[]' '["teamMembers"]')
  local sso=$(fetch_stored_report "teamSSO")

  log_success "Done."

  local team_name=$(echo "$name" | jq -r '.data[0].dimensions.teamName // "N/A"')
  local team_created=$(echo "$created" | jq -r '.data[0].dimensions.teamCreatedDate // "N/A"')
  local current_plan=$(echo "$plan" | jq -r '.data[0].dimensions.currentPlan // "N/A"')
  local billing_freq=$(echo "$billing" | jq -r '.data[0].dimensions.billingFrequency // "N/A"')
  local next_renewal=$(echo "$renewal" | jq -r '.data[0].dimensions.nextRenewalDate // "N/A"')
  local member_count=$(echo "$members" | jq -r '.data[0].measures.teamMembers // "N/A"')
  local sso_provider=$(echo "$sso" | jq -r '.data // "N/A"')

  case "$format" in
    json)
      jq -nc \
        --arg n "$team_name" \
        --arg c "$team_created" \
        --arg p "$current_plan" \
        --arg b "$billing_freq" \
        --arg r "$next_renewal" \
        --arg m "$member_count" \
        --arg s "$sso_provider" \
        '{teamName:$n,teamCreated:$c,currentPlan:$p,billingFrequency:$b,nextRenewal:$r,memberCount:($m|tonumber),ssoProvider:$s}'
      ;;
    csv)
      echo "field,value"
      echo "team_name,\"$team_name\""
      echo "team_created,$team_created"
      echo "current_plan,$current_plan"
      echo "billing_frequency,$billing_freq"
      echo "next_renewal,$next_renewal"
      echo "member_count,$member_count"
      echo "sso_provider,$sso_provider"
      ;;
    table)
      printf "%-20s %s\n" "FIELD" "VALUE"
      printf "%-20s %s\n" "Team Name" "$team_name"
      printf "%-20s %s\n" "Created" "$team_created"
      printf "%-20s %s\n" "Plan" "$current_plan"
      printf "%-20s %s\n" "Billing" "$billing_freq"
      printf "%-20s %s\n" "Next Renewal" "$next_renewal"
      printf "%-20s %s\n" "Members" "$member_count"
      printf "%-20s %s\n" "SSO Provider" "$sso_provider"
      ;;
  esac
}

report_freshness() {
  local format="$1"
  log_info "Fetching data freshness..."
  local json=$(fetch_get_endpoint "/v1/last-refreshed")
  log_success "Done."

  local refreshed_at=$(echo "$json" | jq -r '.lastRefreshedAt // "N/A"')

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "last_refreshed_at"
      echo "$refreshed_at"
      ;;
    table)
      printf "%-20s %s\n" "FIELD" "VALUE"
      printf "%-20s %s\n" "Last Refreshed" "$refreshed_at"
      ;;
  esac
}

report_filters() {
  local format="$1"
  log_info "Fetching available filters..."
  local json=$(fetch_get_endpoint "/v3/filter-listing")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "type,id,name"
      echo "$json" | jq -r '
        (.apis.allApis[]? | ["api", .id, .name]),
        (.apis.teamApis[]? | ["team_api", .id, .name]),
        (.apis.privateNetworkApis[]? | ["pan_api", .id, .name]) | @csv'
      ;;
    table)
      local all_count=$(echo "$json" | jq '.apis.allApis | length')
      local team_count=$(echo "$json" | jq '.apis.teamApis | length // 0')
      local pan_count=$(echo "$json" | jq '.apis.privateNetworkApis | length // 0')
      printf "%-25s %10s\n" "FILTER_TYPE" "COUNT"
      printf "%-25s %10d\n" "All APIs" "$all_count"
      printf "%-25s %10d\n" "Team APIs" "$team_count"
      printf "%-25s %10d\n" "Private Network APIs" "$pan_count"
      ;;
  esac
}

report_workspace_list() {
  local format="$1"
  log_info "Fetching team workspaces list..."
  local json=$(fetch_stored_report "totalTeamWorkspaceDrill")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "workspace_name,workspace_id"
      echo "$json" | jq -r '.data.dataset[]|[.value.workspaceName, (.details[0].redirectPath | split("/")[1])]|@csv'
      ;;
    table)
      echo "$json" | jq -r '
        ["WORKSPACE_NAME", "WORKSPACE_ID"],
        (.data.dataset[]|[.value.workspaceName, (.details[0].redirectPath | split("/")[1])])|@tsv' | column -t -s $'\t'
      ;;
  esac
}

report_forks_prs() {
  local format="$1" limit="${2:-10}"
  log_info "Fetching forks and pull requests data..."
  local json=$(fetch_stored_report "teamWSForksPullRequestsOverTime")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "date,forks,pull_requests"
      echo "$json" | jq -r '
        .data.dataset as $d |
        ($d[0].values | keys[]) as $i |
        [$d[0].values[$i].x, $d[0].values[$i].y, ($d[1].values[$i].y // 0)]|@csv'
      ;;
    table)
      echo "$json" | jq -r --argjson lim "$limit" '
        ["DATE", "FORKS", "PULL_REQUESTS"],
        (.data.dataset as $d |
          ($d[0].values | if length > $lim then .[-$lim:] else . end | keys[]) as $i |
          [($d[0].values | if length > $lim then .[-$lim:] else . end)[$i].x,
           ($d[0].values | if length > $lim then .[-$lim:] else . end)[$i].y,
           (($d[1].values | if length > $lim then .[-$lim:] else . end)[$i].y // 0)])|@tsv' | column -t -s $'\t'
      ;;
  esac
}

report_pan() {
  local format="$1"
  log_info "Fetching Private API Network data..."
  local json=$(fetch_group_report "privateNetworkApis")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "metric,value"
      echo "$json" | jq -r '
        .reports[].value |
        if (.data | type) == "number" then
          [.label, .data]|@csv
        elif (.data | type) == "object" and .data.dataset then
          .label as $lbl |
          .data.dataset[] |
          [($lbl + " - " + .legend), (.values[0].x // .values[0].y // 0)]|@csv
        else
          empty
        end'
      ;;
    table)
      printf "%-45s %15s\n" "METRIC" "VALUE"
      echo "$json" | jq -r '
        .reports[].value |
        if (.data | type) == "number" then
          [.label, .data]|@tsv
        elif (.data | type) == "object" and .data.dataset then
          .label as $lbl |
          .data.dataset[] |
          [($lbl + " - " + .legend), (.values[0].x // .values[0].y // 0)]|@tsv
        else
          empty
        end' | while IFS=$'\t' read -r metric value; do
          printf "%-45s %15s\n" "$metric" "$value"
        done
      ;;
  esac
}

report_environments() {
  local format="$1"
  log_info "Fetching environments list..."
  local json=$(fetch_stored_report "teamWorkspaceEnvironmentDrill")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "environment_name,environment_path"
      echo "$json" | jq -r '.data.dataset[]|[.value.environmentName, .details[0].redirectPath]|@csv'
      ;;
    table)
      echo "$json" | jq -r '
        ["ENVIRONMENT_NAME", "PATH"],
        (.data.dataset[]|[.value.environmentName, .details[0].redirectPath])|@tsv' | column -t -s $'\t'
      ;;
  esac
}

report_mocks_list() {
  local format="$1"
  log_info "Fetching mocks list..."
  local json=$(fetch_stored_report "teamWorkspaceMockDrill")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "mock_name,mock_path"
      echo "$json" | jq -r '.data.dataset[]|[.value.mockName, .details[0].redirectPath]|@csv'
      ;;
    table)
      echo "$json" | jq -r '
        ["MOCK_NAME", "PATH"],
        (.data.dataset[]|[.value.mockName, .details[0].redirectPath])|@tsv' | column -t -s $'\t'
      ;;
  esac
}

report_monitors_list() {
  local format="$1"
  log_info "Fetching monitors list..."
  local json=$(fetch_stored_report "teamWorkspaceMonitorDrill")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "monitor_name,monitor_path"
      echo "$json" | jq -r '.data.dataset[]|[.value.monitorName, .details[0].redirectPath]|@csv'
      ;;
    table)
      echo "$json" | jq -r '
        ["MONITOR_NAME", "PATH"],
        (.data.dataset[]|[.value.monitorName, .details[0].redirectPath])|@tsv' | column -t -s $'\t'
      ;;
  esac
}

report_apis_list() {
  local format="$1"
  log_info "Fetching APIs list..."
  local json=$(fetch_stored_report "teamWorkspaceApiDrill")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)
      echo "api_name,api_path"
      echo "$json" | jq -r '.data.dataset[]|[.value.apiName, .details[0].redirectPath]|@csv'
      ;;
    table)
      echo "$json" | jq -r '
        ["API_NAME", "PATH"],
        (.data.dataset[]|[.value.apiName, .details[0].redirectPath])|@tsv' | column -t -s $'\t'
      ;;
  esac
}

report_api_updates() {
  local format="$1" limit="${2:-10}"
  log_info "Fetching API updates over time..."
  local json=$(fetch_stored_report "teamApiUpdatedOvertime")
  log_success "Done."

  case "$format" in
    json)  echo "$json" ;;
    csv)   format_timeseries_csv "$json" ;;
    table) format_timeseries_table "$json" "$limit" ;;
  esac
}

# ============================================================================
# Usage
# ============================================================================

usage() {
  cat << 'EOF'
postman-report - Fetch Postman team reports

USAGE:
    postman-report [report] [options]
    postman-report --login

USER REPORTS:
    users              User details with join dates, roles (default)
    activity           API requests and collection runs per user
    roles              User roles summary

CONTENT REPORTS:
    summary            Dashboard with key metrics
    apis               API distribution by workspace type
    workspaces         Workspace counts by visibility
    schemas            Schema format distribution (OpenAPI, GraphQL, etc.)
    entities           Entity counts (Collections, APIs, Envs, etc.)

COVERAGE REPORTS:
    coverage           API coverage summary (mocks, monitors, tests, docs)
    coverage mocks     Mock coverage only
    coverage monitors  Monitor coverage only
    coverage tests     Test coverage only
    coverage docs      Documentation coverage only

TREND REPORTS:
    trends             APIs and workspaces created over time
    api-health         Test results, uptime, response time
    api-updates        API updates over time
    engagement         Watches and comments over time
    forks-prs          Forks and pull requests over time

LIST REPORTS:
    collections        List all collections in team workspaces
    workspace-list     List all team workspaces
    apis-list          List all APIs in team workspaces
    environments       List all environments in team workspaces
    mocks-list         List all mocks in team workspaces
    monitors-list      List all monitors in team workspaces

PRIVATE API NETWORK:
    pan                Private API Network metrics and coverage

TEAM REPORTS:
    team               Team info (plan, billing, members, SSO)

SYSTEM REPORTS:
    freshness          Data freshness (when reports were last updated)
    filters            Available filters for dynamic queries (APIs list)

OPTIONS:
    --format json|table|csv    Output format (default: json)
    --limit N                  Limit results for time series (default: 10)
    --raw                      Output raw API response
    --login                    Re-authenticate with Postman
    -h, --help                 Show this help

EXAMPLES:
    postman-report summary --format table
    postman-report coverage --format csv
    postman-report trends --limit 20
    postman-report collections --format table
    postman-report pan --format table
    postman-report workspace-list --format csv
    postman-report team
EOF
}

# ============================================================================
# Main
# ============================================================================

main() {
  local report_type="users"
  local format="json"
  local limit="10"
  local raw=false
  local coverage_subtype=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help) usage; exit 0 ;;
      --login) check_postman_cli; do_login; exit 0 ;;
      --format) format="$2"; shift 2 ;;
      --limit) limit="$2"; shift 2 ;;
      --raw) raw=true; shift ;;

      # User reports
      users|activity|roles) report_type="$1"; shift ;;

      # Content reports
      summary|apis|workspaces|schemas|entities) report_type="$1"; shift ;;

      # Coverage reports
      coverage)
        report_type="coverage"
        shift
        if [[ $# -gt 0 && "$1" =~ ^(mocks|monitors|tests|docs)$ ]]; then
          coverage_subtype="$1"
          shift
        fi
        ;;

      # Trend reports
      trends|api-health|api-updates|engagement|forks-prs) report_type="$1"; shift ;;

      # List reports
      collections|workspace-list|apis-list|environments|mocks-list|monitors-list) report_type="$1"; shift ;;

      # PAN reports
      pan) report_type="$1"; shift ;;

      # Team reports
      team) report_type="$1"; shift ;;

      # System reports
      freshness|filters) report_type="$1"; shift ;;

      *) log_error "Unknown option: $1"; usage; exit 1 ;;
    esac
  done

  check_postman_cli
  check_logged_in || { log_warn "Not logged in."; do_login; }

  # Execute report
  case "$report_type" in
    # User reports (v3 BillingUsersDimension)
    users|activity|roles)
      log_info "Fetching '$report_type' report..."
      local result=$(fetch_user_report "$report_type")
      log_success "Done."
      if [[ "$raw" == true ]]; then
        echo "$result"
      else
        case "$format" in
          json)  echo "$result" ;;
          csv)   format_users_csv "$result" "$report_type" ;;
          table) format_users_table "$result" "$report_type" ;;
        esac
      fi
      ;;

    # Content reports
    summary)     report_summary "$format" ;;
    apis)        report_apis "$format" ;;
    workspaces)  report_workspaces "$format" ;;
    schemas)     report_schemas "$format" ;;
    entities)    report_entities "$format" ;;

    # Coverage reports
    coverage)    report_coverage "$format" "${coverage_subtype:-all}" ;;

    # Trend reports
    trends)      report_trends "$format" "$limit" ;;
    api-health)  report_api_health "$format" "$limit" ;;
    api-updates) report_api_updates "$format" "$limit" ;;
    engagement)  report_engagement "$format" "$limit" ;;
    forks-prs)   report_forks_prs "$format" "$limit" ;;

    # List reports
    collections)     report_collections "$format" ;;
    workspace-list)  report_workspace_list "$format" ;;
    apis-list)       report_apis_list "$format" ;;
    environments)    report_environments "$format" ;;
    mocks-list)      report_mocks_list "$format" ;;
    monitors-list)   report_monitors_list "$format" ;;

    # PAN reports
    pan)         report_pan "$format" ;;

    # Team reports
    team)        report_team "$format" ;;

    # System reports
    freshness)   report_freshness "$format" ;;
    filters)     report_filters "$format" ;;

    *)
      log_error "Unknown report type: $report_type"
      usage
      exit 1
      ;;
  esac
}

main "$@"
